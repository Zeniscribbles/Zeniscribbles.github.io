---
layout: essay
type: essay
title: "Click Clack Clickety Clack"
# All dates must be YYYY-MM-DD format!
date: 2024-10-17
published: true
labels:
  - Electrical and Computer Engineering
  - Software Reverse Engineering
  - Good Coding Practices
  - Coding Standards
  - Software Engineering
---

Click clack clickety clack, the sound of your keyboard as you endlessly drone on in your software engineering course. 

Click clack clickety clack, you chisel away at your web application and design. But wait, isn’t this a software 

engineering course? Why of course it is, web application development is merely a skill you picked up during your time

in software engineering. Do you recall the thrill of mastering Agile Project Management, the meticulousness of 

Configuration Management, or the ethical dilemmas in software engineering?<br><br>


Fret not dear reader, your finals may have stolen your attention, but I shall reignite your passion for all you’ve learned.<br><br>


You may not recall Issue Driven Project Management (IDPM), in fact, it’s not widely recognized within the Agile methodologies. 

Nonetheless, IDPM is a focused and practical approach to Agile Project Management. It emphasizes breaking down tasks into 

clearer, more defined issues. These issues are often tracked in collaborative tools, such as GitHub Issues, to represent discrete 

tasks that can be assigned and resolved efficiently. Not so unfamiliar anymore is it, perhaps you are beginning to recall the

ease of task management in GitHub Issues. Outside of web development, IDPM works beautifully for Cybersecurity Projects.

Issues in penetration testing or vulnerability assessments can be focused on individual exploits, network scans, or security 

recommendations. If that’s not your cup of tea, how about game development? Issues in game development can be broken down 

into tasks like character animation design, coding character behaviors, or optimizing rendering pipelines.<br><br>



Ah, do you remember learning about Configuration Management (CM)? You likely remember CM as the practice of maintaining 

consistency and control over the settings, dependencies, and infrastructures that made up your web application projects.

CM involves identifying, documenting, and maintaining the state of a system’s components throughout its lifecycle—a critical 

discipline across different domains of engineering and IT. CM keeps system configurations version-controlled and auditable.

A perfect example is Aerospace and Defense. In mission-critical systems, CM ensures documentation, change control, and 

software-hardware dependencies are tracked, monitored for vulnerabilities or compromises, and compliant with regulations.

Oh Ethics, the topic that both horrified you and intrigued you all at the same time.<br><br>

Do you remember the AI self-driving car ethics quiz, where no matter what you answer people still died? Ethics in software 

engineering often revolves around such complex decisions, where trade-offs and unintended consequences must be considered 

carefully. One real-world example that embodies these challenges is the infamous Stuxnet malware, first discovered in 2010. 

Recognized as the first cyber weapon, Stuxnet exploited multiple zero-day vulnerabilities and demonstrated how software 

could be used to achieve real-world destruction. It manipulated industrial control systems to subtly alter centrifuge 

operations, causingphysical damage while masking its presence. But why is Stuxnet more than just a cybersecurity story? 

For software engineers, it highlights the immense power—and responsibility—we hold. Stuxnet’s creation and deployment 

raise questions about accountability, transparency, and the ethical boundaries of software use. When building software, 

engineers must consider: Who bears responsibility for unintended consequences? How do we balance innovation with potential 

misuse? Stuxnet also underscores the critical importance of security in software design. A single vulnerability in code 

can have cascading effects, leading to ethical dilemmas that ripple across industries and even nations. The lessons of 

Stuxnet extend to every software engineering project, urging us to think about the potential impact of our work. As

engineers, we are not just writing lines of code; we are shaping tools that could influence lives, economies, and societies. 

The responsibility to build secure, transparent, and ethical systems cannot be overstated.<br><br>


Through these lessons, software engineering reveals itself as a discipline far greater than web development—a craft of precision, 

collaboration, and ethical accountability that transcends industries. <br><br>

So dear reader, are you reinspired?

